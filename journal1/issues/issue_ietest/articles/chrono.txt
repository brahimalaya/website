@BRHTML:article
This is the short sad story <i>chrono</i> widget that takes life thanks to the help of some <i>CSS magic</i> (and a pair of CSS sprites too).
The <i>chrono</i> widget source code is enough (I hope) documented and should show most of the widget features. Let's list and spend a pair of words about all of them.
When the widget starts it <i>self-parses</i> its <i>widget container tag</i> looking for child elements. When empty, it creates some default unstyled gray rectangles. If it finds anything instead, it will find the first tags the attribute <i>chronoelement</i> valued as <i>stop</i>, <i>timer</i> and <i>event</i> and uses them as stop button, time and event output. Anything else is ignored so you can enrich the widget instance with more graphics, like the triangles in the tail of the clock on the bottom right of this page.
Then, it starts <i>two processes</i>, one for making the timer blink and one for counting time. Widgets can start up and stop multiple scheduled calls to their methods (or global methods) and do pseudo-simultaneous actions. These scheduled actions are automatically paused by #toolname# when the page is dragged and cancelled when the page is left, that transparently optimize and speed up navigation on animations filled pages.
After started counting, it "attaches" the click method of the <i>stop</i> child to one of the widget's actions, that will kill the time counting process, leaving the blinking one running. The widget will <i>kill</i> the process using the ID given by the scheduler. So, when the <i>stop</i> button is clicked, the counter is stopped.
The counter process will <i>kill himself</i> when reaches its maximum value. That is done just returning <i>true</i> to the scheduler when the process is cycled.
The maximum value is taken from an attribute of the <i>widget container tag</i>. The widgets instances are DIVs marked with the <i>interactive=yes</i> and <i>widget=chrono</i> attributes. The <i>chrono</i> widget will also check the <i>max=&laquo;value&raquo;</i> attribute that will be the maximum value of the counter. Every instance of the widget can have different parameters, so the three counters on the page will stop at different values.
Widgets can also react to broadcasted events, like when the page is dragged and dropped. These events are triggered on the <i>widget container tag</i> and can be used for a many purposes. The <i>onevent</i> is triggered when any event is received so can be used as debug - just like is already doing the <i>chrono</i> widget.
Aesthetics are done with CSS styles applied to the components of the clock.

